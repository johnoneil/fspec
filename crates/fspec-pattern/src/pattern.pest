// ---- Top level ----

number = @{ ASCII_DIGIT+ }
WS = _{ " " | "\t" | "\r" | "\n" }

pattern     = { SOI ~ node* ~ EOI }

node        = _{ globstar | slash | named_placeholder | literal }

// ---- Nodes ----

// Treat "/" as its own node (matches your AST)
slash       = { "/" }

// "**" becomes GlobStar
globstar    = { "**" }

// "{name[:limiter]?}" becomes Placeholder
named_placeholder = { "{" ~ WS* ~ ident ~ WS* ~ (":" ~ WS* ~ limiter_call)? ~ WS* ~ "}" }

// Everything else is a Literal chunk.
// We chunk literals so you can merge consecutive Literal nodes easily.
literal     = { literal_piece+ }

// ---- Identifiers ----

// Keep this strict to make errors crisp and to match your unit tests.
// (No spaces; starts with alpha/_; continues alnum/_)
ident       = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

// ---- Limiters ----

limiter     = { limiter_kind ~ limiter_args? }

// NOTE: These have to explicitly match the code in parser.rs
// Please show great care to ensure they do as this is obviously weak.
// see also: https://stackoverflow.com/a/54330161
// flatcase or mumblecase
// kebab-case. Also called caterpillar-case, param-case, dash-case, hyphen-case, lisp-case, spinal-case and css-case
// camelCase
// PascalCase or CapitalCamelCase
// snake_case or c_case
// CONSTANT_CASE, MACRO_CASE, UPPER_CASE or SCREAM_CASE
// COBOL-CASE or TRAIN-CASE
// Ada_Case
limiter_kind = @{
      "int"
    | "semver"
    | "snake_case"
    | "kebab_case" | "kebab-case"
    | "camel_case" | "camelCase"
    | "pascal_case" | "PascalCase"
    | "flat_case" | "flatcase"
    | "upper_case" | "UPPER_CASE"
}

// Optional “( … )” arguments: either a quant or a set.
//limiter_args = { "(" ~ (quant | set_items) ~ ")" }
limiter_call = { limiter_kind ~ WS* ~ "(" ~ WS* ~ limiter_args? ~ WS* ~ ")" }

limiter_args = { quant }   // or a union if you have other arg forms

// Quantifiers: exactly, at-least, range, any
quant       = { range | at_least | exactly | any }

exactly  = { number } // (4)
at_least = { number ~ WS* ~ "+" ~ WS* }// (4+)
range    = { number ~ WS* ~ "-" ~ WS* ~ number } // (4-5)
any      = { "*" } // <nothing>

// Example: oneof style, e.g. (mp4,mov,mkv)
// (If you prefer `{mp4,mov}` without a limiter kind, see note below.)
set_items   = { ident ~ ("," ~ ident)* }

// literal_piece is either an escaped char or any char that doesn’t start a special token.
// We exclude '/', '{', and the start of "**" to avoid ambiguity.
literal_piece = _{
      escape
    | (!special ~ ANY)
}

//special     = _{ "/" | "{" | "*" } // '*' is special because of globstar "**"
special = _{ "/" | "{" | "}" | "*" }

escape      = { "\\" ~ ANY }
