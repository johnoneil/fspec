// ---- Top level ----

number = @{ ASCII_DIGIT+ }
WS = _{ " " | "\t" | "\r" | "\n" }

// pattern     = { SOI ~ node* ~ EOI }

// node        = _{ globstar | slash | placeholder | literal }

// ---- Nodes ----

// Treat "/" as its own node (matches your AST)
slash       = { "/" }

// "**" becomes GlobStar segment.
globstar_segment    = { "**" }

// "*" becomes star segment.
star_segment = { "*" }

// "." becomes dot segment.
dot_segment = { "." }

// ".." becomes dotdot segment.
dotdot_segment = { ".." }

// "{name[:limiter]?}" becomes a named placeholder, the limiter is optional
named_placeholder = { "{" ~ WS* ~ ident ~ WS* ~ (":" ~ WS* ~ limiter_call)? ~ WS* ~ "}" }

// "{limiter()}" is an anonymous placeholder. no name specified but legal"

anonymous_placeholder = { "{" ~ WS* ~ limiter_call ~ WS* ~ "}" }

placeholder = { anonymous_placeholder | named_placeholder }

// Everything else is a Literal chunk.
// We chunk literals so you can merge consecutive Literal nodes easily.
literal     = { literal_piece+ }

// ---- Identifiers ----

// Keep this strict to make errors crisp and to match your unit tests.
ident       = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }

//ident = @{ ASCII_ALPHA_LOWER ~ (ASCII_LOWER | ASCII_DIGIT | "_")* }

// ---- Limiters ----

limiter     = { limiter_kind ~ limiter_args? }

// NOTE: These have to explicitly match the code in parser.rs
// Please show great care to ensure they do as this is obviously weak.
// see also: https://stackoverflow.com/a/54330161
// flatcase or mumblecase
// kebab-case. Also called caterpillar-case, param-case, dash-case, hyphen-case, lisp-case, spinal-case and css-case
// camelCase
// PascalCase or CapitalCamelCase
// snake_case or c_case
// CONSTANT_CASE, MACRO_CASE, UPPER_CASE or SCREAM_CASE
// COBOL-CASE or TRAIN-CASE
// Ada_Case
limiter_kind = @{
      "int"
    | "semver"
    | "snake_case"
    | "kebab_case" | "kebab-case"
    | "camel_case" | "camelCase"
    | "pascal_case" | "PascalCase"
    | "flat_case" | "flatcase"
    | "upper_case" | "UPPER_CASE"
}

// Optional “( … )” arguments: either a quant or a set.
//limiter_args = { "(" ~ (quant | set_items) ~ ")" }
limiter_call = { limiter_kind ~ WS* ~ "(" ~ WS* ~ limiter_args? ~ WS* ~ ")" }

limiter_args = { quant }   // or a union if you have other arg forms

// Quantifiers: exactly, at-least, range, any
quant       = { range | at_least | exactly | any }

exactly  = { number } // (4)
at_least = { number ~ WS* ~ "+" ~ WS* }// (4+)
range    = { number ~ WS* ~ "-" ~ WS* ~ number } // (4-5)
any      = { "*" } // <nothing>

// Example: oneof style, e.g. (mp4,mov,mkv)
// (If you prefer `{mp4,mov}` without a limiter kind, see note below.)
set_items   = { ident ~ ("," ~ ident)* }

// literal_piece is either an escaped char or any char that doesn’t start a special token.
// We exclude '/', '{', and the start of "**" to avoid ambiguity.
literal_piece = { (!("/" | "{") ~ ANY)+ }

//special     = _{ "/" | "{" | "*" } // '*' is special because of globstar "**"
special = _{ "/" | "{" | "}" | "*" }

escape      = { "\\" ~ ANY }

soi = { SOI }
eoi = { EOI }

//pattern = { (slash | segment)* }    // or SOI/EOI wrapped
//pattern = { SOI ~ (slash | segment)* ~ EOI }
pattern = { soi ~ (slash | segment)* ~ eoi }

segment_node = { slash | segment }

segment = { path_segment } // no need for “| parts_segment” because path_segment already includes it

parts_segment = { (literal_piece | placeholder)+ }
path_segment  = { globstar_segment | dotdot_segment | dot_segment | star_segment | parts_segment }
