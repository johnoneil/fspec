
[identifiers]
version = "{semver}"
date = "{DDMonYY}"

# proclint is meant for mid to highly formalized processes, in this case
# we'd at a minimum have a software design document.
[file.software_design]
# design docs follow a strict naming convention and date format like 25Dec25
pattern = "designs/**/{name:PascalCase}_{date}.pdf"

# all c source under source and camelcase
[file.c_source]
pattern = "source/**/{name:camelCase}.c"
depends = [
  # c source depends on the latest design doc (matched by latest date in filename)
  "software_design latest_by date"
]
rules = [
  # c source files MUST have an associated unit test, matched by name field.
  # Note this is a *rule* not a dependency. Dependencies describe how downstream
  # changes flow. Rules determine whether an individual file conforms to process.
  "c_unit_test exists by name"
]

# all c headers directly under headers (no subdirectories) and UPPERCASE
[file.c_header]
pattern = "headers/{name:UPPERCASE}.h"
depends = [
  # headers depend on software design also. On design change, they must be revalidated.
  "software_design latest_by date",
]

# Unit tests
[file.c_unit_test]
pattern = "tests/**/{name:camelCase}_unit_test.c"
depends = [
  # unit tests should be updated when corresponding source is updated.
  "c_source by name",
]
rules = [
  # generate a warning when there are orphaned tests
  "c_source exists by name warning"
]

# releases (checked into config management)
[file.release]
patterns = [
  "releases/{version}/win32/windowsInstaller_{version}.exe",
  "releases/{version}/macos/macInstaller_{version}.dmg",
  "releases/{version}/linux/linux_{version}.gzip"
]

# the latest (only) release depends on all source.
# if any source files are newer than the latest release, we know
# the release is stale.
[file.latest_release]
# TODO:
inherent = "release"
# TODO:
selector = "latest_by version"
depends = [
  "c_source all",
  "c_header all",
  "c_unit_test all"
]
